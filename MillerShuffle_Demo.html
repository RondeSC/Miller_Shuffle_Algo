<!DOCTYPE html>
<!-- Shuffle Algorithm Comparison and demonstrated use of the a Miller Shuffle Algorithm -->
<!-- source: https://github.com/RondeSC/Miller_Shuffle_Algo -->
<!-- Ron Miller Jan 2025, Cobbled together from multiple development efforts -->
<!-- Ron Miller Aug-Sep 2025, Expanded and Improved statistics and Graphing & Plotting -->

<!-- Note that some statistic calculations may have inaccuracies of ~0.5% (or 1/256) due to straight forward implementations -->
<!-- That is tolerated, as statistics from a random datasets may vary +/-10% and the code to handle the odd case may add 20% complexity  -->

<!-- Note that statistics in the table are the average of the stats of many individual shuffles -->
<!-- while the ones printed at the bottom, are statistics for a dataset made up from the collection of many shuffles  -->

<html>
<head>
	<title>View Shuffles</title>
	<script type="text/javascript" src="MillerShuffle.js"></script>

	<style>
		<!-------------------------- CSS dictated look & fell ----------------------->
		body {
			margin: 0;
		}

		canvas {
			border: 1px solid #000;
		}

		/* ----------------  Individual radio button */
		.radio-container {
			display: flex;
			gap: 10px;
			margin: 10px;
			margin-left: 0px;
		}

		/* Individual radio button containers */
		.radio-box {
			position: relative;
			width: 100px;
		}

		/* Style radio buttons to appear rectangular */
		input[type="radio"] {
			appearance: none;
			background-color: #fff;
			border: 2px solid #333;
			padding: 15px;
			width: 100%;
			height: 40px;
			cursor: pointer;
			transition: all 0.3s ease;
			box-sizing: border-box;
		}

		/* Position labels inside rectangles */
		.radio-box label {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-family: Arial, sans-serif;
			white-space: nowrap;
			margin-left: 4px;
		}

		/* Selected state */
		input[type="radio"]:checked {
			background-color: #10A0FF;
			color: white;
		}

		.ball-container {
			position: relative;
			width: 750px;
			height: 130px;
			background-color: lightgreen;
		}

		.ball-line {
			display: flex;
			width: 750px;
			position: relative;
		}

		.ball {
			width: 50px;
			height: 50px;
			margin: 0px;
			background-size: cover;
			position: absolute;
			transition: transform 0.3s ease;
		}

		.solid-border {
			border: 2px solid black;
			padding: 12px;
		}

		.active {
			background-color: bisque;
		}

		/* Style for disabled checkbox and label */
		.checkbox-container.disabled input[type="checkbox"],
		.checkbox-container.disabled label {
			opacity: 0.5;
			cursor: not-allowed;
			pointer-events: none;
		}
	</style>
</head>

<!------------------------------- HTML super structure -------------------------------------->
<body>
	<div style="background-color: aliceblue;">
		<div style="float: left; margin: 10px;">
			<center><h1 style="margin-top: 0px;">Shuffle Algorithm Comparison </h1> </center>

			<p>Compares Shuffle methods of generating "random" permutations of 256 numbers / 15 items:</p>
			<ul>
				<li>Human card shuffle simulations</li>
				<li>Fisher-Yates Shuffle (pseudo-random, shuffle)</li>
				<li><a href="https://docs.google.com/document/d/1UOzZNXHsaTuRHNFvPH_tQwVWfTXUj9xP">Miller Shuffle Algo (Pseudo Random Index Generator)</a></li>
				<li>Math.random() (pseudo-random)</li>
				&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - plus -
				<br />
				<li>Identity (control, non-random) ...</li>
				<li>Expected (Ideal Randomness)</li>
			</ul>

			<!--table id="results" style="width: -webkit-fill-available; text-align: left;"-->
			<!-- <table id="results" style="width: -moz-available; text-align: left;"> -->
			<table id="results" style="width: 100%; text-align: left;">
				<tr>
					<th>Method</th>
					<th>Chi<br />Squared</th>
					<th>Relative<br />Displacement</th>
					<th>Mean &nbsp; &nbsp; &nbsp; </th>
					<th>Standard<br />Deviation</th>
					<th>Calculated<br />Avg Error%</th>
				</tr>
			</table>

			<div class="radio-container">
				<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt1">
					<label for="opt1">Identity</label>
				</div>

				<div class="radio-box">
					<input type="radio" name="option" value="2" id="opt2">
					<label for="opt2">Human</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="2" id="opt3">
					<label for="opt3">Human Pro</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="3" id="opt4">
					<label for="opt4">Fisher-Yates</label>
				</div>

				<div class="radio-box">
					<input type="radio" name="option" value="4" id="opt5">
					<label for="opt5">MSA PRIG</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="5" id="opt6">
					<label for="opt6">Random()</label>
				</div>
			</div>

			<div class="radio-container">
				<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt7">
					<label for="opt7">DblDeckDeal</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt8">
					<label for="opt8">weak PRIG</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt9">
					<label for="opt9">poor PRIG</label>
				</div>
				<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt10">
					<label for="opt10">faux PRIG</label>
				</div>
				<!--<div class="radio-box">
					<input type="radio" name="option" value="1" id="opt11">
					<label for="opt11">test Algo</label>
				</div>-->

			</div>
		</div>

		<div class="solid-border" style="display: flow-root; width: 515px; padding-bottom: 2px;">
			<div style="color: lightskyblue;">
				<canvas id="myCanvas" width="515" height="515"></canvas>
				<center>
					<big>Shuffled Snow Flurry</big> &nbsp;
					<input type="range" min="2" max="72" value="40" id="speedSlider">
					<span style="color: gray;">
						<span class="checkbox-container"><label><input type="checkbox" id="aging" checked="checked">Aging</label></span>
						<label><input type="checkbox" id="dvData">dV &nbsp;</label>
						<label><input type="checkbox" id="viData">dI</label>
						<!--<input type="checkbox" id="viData">-->
					</span>
				</center>
			</div>
		</div>
	</div>

	<div class="ball-container" class="solid-border" id="ballContainer" style="display:inline-block;">
		<div style="margin-bottom: 3px;">
			<big><bold> Pool Ball "LOTO" </bold></big> <small>(when done with a PRIG, or mechanical shuffle, Fisher-Yates or Human)</small>
			<span style="margin-left: 40px;"> <span id="selCnt"></span> selection: (<span id="ball"></span>)
		</div>
		<div class="ball-line" id="firstLine"></div>
		<div class="ball-line" id="secondLine"></div>
	</div>
	<div style="display: inline-table; margin-left: 15px;">
		<button id="pauseButton">Pause Processing</button>
		<span id="dataType" style="color: gray;">  </span> <br />
		<span style="color: gray;">
			<label><input type="checkbox" id="histogram">Histogram of </label>
			<span id="histoType">values</span>&nbsp;
			<label><input type="checkbox" id="scatterPlot" style="margin-left: 24px;">Plot value pair occurrences</label>
		</span>
		<div id="notice" style="text-align: center;"></div>
	</div>

	<div id="ballShuffleStats" style="color: darkgreen; border-top: groove;"></div>
	<div id="results-container" style="xdisplay: inline-flex">
		<pre id="results-output" style=" margin: 0;"></pre>
	</div>
	<div style="color: darkgoldenrod;">------------ area for the reporting of Diagnostics ----------------</div>
	<div id="diagArea" style="color: darkslategray;"> </div>

	<div id="chksumArea"> </div>

	<!---------------------------- JavaScript action code ------------------------------->
	<script>

		let ptCnt = 0; // running count of point generation
		let newPts;
        let pts = Array(256).fill().map(() => Array(256));
        let nCnt = [26];

		const diag = true;
		const diagLog = document.getElementById('diagArea');
        let flurryID = 314159;
		let algo = 4;  // start off with MSA PRIG
		let algoOpt = "opt5";
		let dType;
		let pro = false;
		let newAlgo = true;
		let dvData = false;
		let viData = false;
		let rawX = false;
		let algoName = "MSA PRIG";
		let iStack = true;
		let Hist = false;
		let scatterPlot = false;
		let isPaused = false;
		let randID = 0; // when set it overrides the shuffleID
		shuffleID = 31416;	// global var in MillerShuffle.js

		const canvas = document.getElementById('myCanvas');
		const ctx = canvas.getContext('2d');
		let bGnd = '#124'; // a dark blue like the evening sky
		let statIntvId = {};

		const radioButtons = document.querySelectorAll('input[name="option"]');
		radioButtons.forEach(radioButton => { radioButton.checked = false; });    // needed for FireFox use


		document.addEventListener('DOMContentLoaded', function () {
			const radioGroup = document.querySelectorAll('input[type="radio"]');
			radioGroup.forEach(button => {
				button.addEventListener('change', handleRadioChange);
			});
			const chkBoxes = document.querySelectorAll('input[type="checkbox"]');
			chkBoxes.forEach(box => {
				box.addEventListener('change', handleChkBoxChange);
			});
		});

		document.getElementById('pauseButton').addEventListener('click', function (event) {
			isPaused = !isPaused;
			if (isPaused) {
				event.target.textContent = ' === PAUSED === ';
			} else {
				event.target.textContent = 'Pause Processing';
			}
		});

		// button press, changing the Algo being used to produce points for the scatter plot & more
		function handleRadioChange(event) {
			algo = Number(event.target.value);
			newAlgo = true;
            console.clear();
			algoOpt = event.target.id;
 			dvData = document.getElementById('dvData').checked;
			viData = document.getElementById('viData').checked;

			var tab = document.getElementById('results');
			for (const row of tab.rows) {
				row.classList.remove('active');
			}
			if (algo == 2) {
				pro = ("opt3" == event.target.id);
			}

			algoName = event.target.nextElementSibling.textContent;
			setMethodName();
		}

		function restartStats() {
			document.getElementById('ballShuffleStats').innerHTML = "";
			stats = [];
			updateStats(algo);
			clearInterval(statIntvId); // Stop the update interval
			statIntvId = setInterval(periodicStats, 1000);   // update every 1.0 secs
			clearCanvas();
			createBalls();
		}

		function handleChkBoxChange(event) {
            document.getElementById('notice').innerHTML = "";
			if ("dvData" == event.target.id) {
				dvData = event.target.checked;
				if (dvData) { viData = false; document.getElementById('viData').checked = false; }
				newAlgo = true;
			} else if ("viData" == event.target.id) {
				viData = event.target.checked;
				if (viData) { dvData = false; document.getElementById('dvData').checked = false; }
				newAlgo = true;
			}
			if (newAlgo) {
				setMethodName();
                document.getElementById('diagArea').innerText += " " + dType + " ";
			}

			if ("histogram" == event.target.id) {
				if (Hist && !(dvData || viData) && !rawX) {
					rawX = true;
					event.target.checked = true;
					//return;
				} else {
					rawX = false;
				Hist = event.target.checked;
				if (Hist) { scatterPlot = false; document.getElementById('scatterPlot').checked = false; }
				}
			} else if ("scatterPlot" == event.target.id) {
				scatterPlot = event.target.checked;
				if (scatterPlot) {
					oldSpeed = speed;
					speedSlider.value = 100; // speedSlider.max;
					speed = 100;
				} else {
                    speedSlider.value = oldSpeed; // speedSlider.max;
                    speed = oldSpeed;
				}
			}
			if (scatterPlot) {
                bGnd = '#000';
				Hist = false;
				document.getElementById('histogram').checked = false;
				document.getElementById('notice').innerHTML = "WAIT, Wait, wait for It ...";
                document.querySelector('.checkbox-container').classList.add('disabled');
			} else {
                bGnd = '#124';
				document.getElementById('notice').innerHTML = "";
                document.querySelector('.checkbox-container').classList.remove('disabled');
			}

			let el = document.getElementById('histoType');
			if (Hist) {
				if (dvData) el.innerHTML = "<b>deltaV </b>";
				else if (viData) el.innerHTML = "<b>delta I </b>";
				else {
					if (rawX) el.innerHTML = "<b>rawVal </b>";
					else el.innerHTML = "<b>Values </b>";
				}
			} else el.innerHTML = "values ";

            if ("aging" != event.target.id) clearCanvas();
		}

		function setMethodName() {
			//let algoName = algoNames[algo - 1];
			let name = algoName;
			if (dvData) name += " - dV";
			if (viData) name += " - dI";
			rows[algo - 1].cells[0].innerHTML = name;
			// tell viewer what type data is being processed
			dType = "(v)"
			if (dvData) dType = "(dv)";
			if (viData) dType = "(di)";

			let opt = parseInt(algoOpt.match(/\d+/)[0]);
            console.log(" algo:", algo, "-", opt, "  (", dType, ")");
            document.getElementById('diagArea').innerText += " algo:" + algo + "-" + opt;
            pType = "v0,v1"  // coordinate Point type
            if (dvData) pType = "v,dv";
			if (viData) pType = "di,i";
			document.getElementById('dataType').innerHTML = " &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Data being Tested & Plotted: <b>" + pType + "</b>";
			rows[algo - 1].classList.add('active');
            Unique_Temporal_Stats();
			restartStats()
		}

		//=============================================================== Algo statistics support
		//=======================================================================================
		const table = document.getElementById("results");
		const rows = [];
		let rowCnt = 0;
		let dump = true;
		var updnum = 0;

		function periodicStats() {
			//updnum++;
			if (!isPaused) {
				updateStats(algo);  // update the randomness stats for the current algo
			}
		}

		function displayResults(methodName, results) { // builds the Table of randomness statistics
			const row = table.insertRow();
			rows.push(row);
			const nameCell = row.insertCell();  // rows and cells are created on the fly
			const chiSquaredCell = row.insertCell();
			const relVecMagCell = row.insertCell();
			const meanCell = row.insertCell();
			//const deltaMeanCell = row.insertCell();
			const stdDevCell = row.insertCell();
			const piErrorCell = row.insertCell();

			nameCell.textContent = methodName;
			//chiSquaredCell.textContent = results.ChiSquared.toFixed(0);
			chiSquaredCell.textContent = results.ChiSquared;
			relVecMagCell.textContent = results.relVecMag;
			meanCell.textContent = results.mean;
			//deltaMeanCell.textContent = results.deltaMean;
			stdDevCell.textContent = results.stdDev;
			//piErrorCell.textContent = results.piError;
			piErrorCell.textContent = results.avgError;
		}

		// ------------ initially: exercize all the shuffle algos, collect and display their statistics
		let range = 256;
		const size = 256;
		let histoCnts = [];
		let lastStack = [];

		// Creating "shuffled" arrays for each algo to then calculate randomness statistics from.
		let identityArray = identity(size); 
		const identityStats = calculateStats(identityArray);
		const humanStats = calculateStats(humanShuffle(size));
		const fisherYatesStats = calculateStats(fisherYatesShuffle(size));
		const msaPRIG_Stats = calculateStats(MSA_PRIG_Array(size));
		const randomScaledStats = calculateStats(randomScaled(size));
		const expectedStats = calculateExpectedStats(size);

		identityStats.ChiSquared = 0; // correctly init it
        expectedStats.stdDev += " !";   // Expected exact! stats for values returned by a PRIG algo
        expectedStats.mean += " !";
		let algoNames = ["Identity", "Human Shuffle", "Fisher-Yates", "MSA PRIG", "Random PRNG"];
		displayResults("Identity", identityStats);
		displayResults("Human Shuffle", humanStats);
		displayResults("Fisher-Yates", fisherYatesStats);
		displayResults("MSA PRIG", msaPRIG_Stats);
		displayResults("Random PRNG", randomScaledStats);
		displayResults("Expected/Ideal", expectedStats);

		// Highlight some cells that are known to be telling
		document.querySelector("#results > tbody > tr:nth-child(2) > td:nth-child(2)").style.backgroundColor = 'lightpink';
		document.querySelector("#results > tbody > tr:nth-child(2) > td:nth-child(3)").style.backgroundColor = 'lightpink';
		document.querySelector("#results > tbody > tr:nth-child(2) > td:nth-child(6)").style.backgroundColor = 'lightpink';
		document.querySelector("#results > tbody > tr:nth-child(3) > td:nth-child(2)").style.backgroundColor = '#FFD0D1';
		document.querySelector("#results > tbody > tr:nth-child(3) > td:nth-child(3)").style.backgroundColor = '#FFD0D1';
		document.querySelector("#results > tbody > tr:nth-child(3) > td:nth-child(6)").style.backgroundColor = '#FFD0D1';
		document.querySelector("#results > tbody > tr:nth-child(6) > td:nth-child(4)").style.backgroundColor = '#FFD0D1';
		document.querySelector("#results > tbody > tr:nth-child(6) > td:nth-child(5)").style.backgroundColor = '#FFD0D1';


		// ==============================================================  Shuffle Algos ...
		// have standardized all Algos to generate an array of (size)

		function MSA_PRIG(inx, shuffleID, size) {  // uses the Miller Shuffle Algo (MSA_e)
			let item = MillerShuffle(inx, shuffleID, size);
			return item;
		}

		function MSA_PRIG_Array(size) {  // uses the Miller Shuffle Algo (MSA_e)
			let array = [];
			for (let i = 0; i < size; i++) {
				array.push(MillerShuffle(i, shuffleID, size));
			}
			return array;
		}

		function fisherYates(array) {  // as normally implemented
			let currentIndex = array.length, randomIndex;
			while (currentIndex != 0) {
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex--;
				[array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
			}
			return array;
		}

		function fisherYatesShuffle(size) {
			const array = [];
			var randomIndex;
			let currentIndex = size;

			for (let i = 0; i < size; i++) { // init the array
				array.push(i);
			}
			fisherYates(array); // have F-Y algo shuffle the array
			return array;
		}

		function randomScaled(size) {  // straight random() of a range, without collision handling
			const array = [];
			for (let i = 0; i < size; i++) {
				array.push(Math.floor(Math.random() * size));
			}
			return array;
		}

		// generate an "identity" shuffle, alternately use other algorithms for testing
		function identity(size) {
			let array = [];
			let asize = size;
			if (algoOpt == "opt7") asize = 2 * size;  // to accommodate Dbl Deck Dealing
			for (let i = 0; i < asize; i++) {
				if (algoOpt == "opt7") {
                    array.push(DDeck_Shuffle(i, size));
                } else if (algoOpt == "opt8") {
                    array.push(weak_PRIG(i, shuffleID, size));
				} else if (algoOpt == "opt9") {
                    array.push(poor_PRIG(i, shuffleID, size));
				} else if (algoOpt == "opt10") {
                    array.push(faux_PRIG(i, shuffleID, size));
				} else if (algoOpt == "opt11") {
                    array.push(test_Shuffle(i, shuffleID, size));
				} else {
					array.push(i);
				}
			}
			return array;
		}

		// ------------------------------------ simulate that of a Human shuffling
		function humanShuffle(numItems) {

			let items = [];
			let newItems = [];
			for (let i = 0; i < numItems; i++) {
				items.push(i);
			}
			const deckSize = items.length;

			// 1. Cut needed to move items off the top & bottom
			var cutPoint = Math.floor(Math.random() * (deckSize - 2)) + 1;
			var topHalf = items.slice(0, cutPoint);
			var bottomHalf = items.slice(cutPoint);
			items = bottomHalf.concat(topHalf);

			/***  // had little to no effect in light of the Riffle Shuffles, so as not to be worth the code. "no code is good code"
				// 2. Overhand Shuffle
				var overhandShuffles = Math.floor(Math.random() * 3) + 2;
				let newItems = [];
				for (let i = 0; i < 0*overhandShuffles; i++) {
					let remainingCards = items.length;
					while (remainingCards > 0) {
						let takeAmount = Math.floor(Math.random() * Math.min(10, remainingCards)) + 1;
						newItems = newItems.concat(items.splice(0, takeAmount));
						remainingCards -= takeAmount;
					}
					items = newItems;
					newItems = [];
				}
			***/

			var numRiffles = 4;
			var rif = 6;
			if (pro) { numRiffles = 6; rif = 4; }
			//rif=3;  //  this made for ~50% (too much, unreal) improvement

			// typical player may do 2-4 Riffle Shuffles with 1-6 cards in each dovetail 'rif'
			// a pro card handler likely do 4-7 Riffle Shuffles with 1-3? cards in each dovetail
			// 3. & 4. & 5... Riffle Shuffles (four times)
			for (let riffle = 0; riffle < numRiffles; riffle++) {
				const rifflePoint = Math.floor(deckSize / 2);

				if (pro) // -------- Do an intervening Cut ~1/4 (1/6 - 1/3)	 (made for <5% improvement)
				{       //   Key to keep deck top & bottom items from staying nearby. (chk ball 1 &15)
					var cutPoint = Math.floor(Math.random() * (deckSize / 6)) + (deckSize / 6);
					var topHalf = items.slice(0, cutPoint);
					var bottomHalf = items.slice(cutPoint);
					items = bottomHalf.concat(topHalf);
				}

				const leftHalf = items.slice(0, rifflePoint);
				const rightHalf = items.slice(rifflePoint);
				newItems = [];
				let leftIndex = 0;
				let rightIndex = 0;

				while (leftIndex < leftHalf.length || rightIndex < rightHalf.length) {
					let takeFromLeft = 0;
					let takeFromRight = 0;
					if (leftIndex < leftHalf.length) {
						takeFromLeft = Math.floor(Math.random() * rif + 0.5) + 1;
						takeFromLeft = Math.min(takeFromLeft, leftHalf.length - leftIndex);
						newItems = newItems.concat(leftHalf.slice(leftIndex, leftIndex + takeFromLeft));
						leftIndex += takeFromLeft;
					}
					if (rightIndex < rightHalf.length) {
						takeFromRight = Math.floor(Math.random() * rif + 0.5) + 1;
						takeFromRight = Math.min(takeFromRight, rightHalf.length - rightIndex);
						newItems = newItems.concat(rightHalf.slice(rightIndex, rightIndex + takeFromRight));
						rightIndex += takeFromRight;
					}
				}
				items = newItems;
			}
			return items;
		}

        // ----------------------------------------------- highlighted would-be shuffling Algorithms

		function weak_PRIG(inx, mixID, listSize) {  // -------  old weak PRIG
            let si, r1, r2;
            const p1 = 50021, p2 = 63629;
            let maxBin;
            let sh;

            // compute reference values for later
            maxBin = 1;
            while ((2 * maxBin + 1) < listSize) maxBin = 2 * maxBin + 1;
			r1 = mixID % 1009;   // constant values are not super important
			r2 = mixID % 1019;
			si = (inx + mixID) % listSize;  // an initial cut

			// ------ plenty of effort, but not the best results ------ //
            si = (si * p1 + r1) % listSize;  // relatively prime gears turning operation
            if (si <= maxBin && si != 0) {  // This one middle action does the added mix up.
				// --- now for the would-be secret sauce of MSA_c ...
                for (sh = 0; (maxBin >> sh) >= si; sh++);  // set to do smart masked XOR operation
                si = si ^ ((0x5555 & maxBin) >> sh);      // note: operator order is important
            }
            if (si % 3 == 0) si = ((Math.floor(si / 3) * p1 + r1) % Math.floor((listSize + 2) / 3)) * 3; // spin multiples of 3 
            si = (si * p2 + r2) % listSize; // turn more prime wheels

            return (si);  // return 'Shuffled' index
        }

		function poor_PRIG(inx, mixID, listSize) {	// -------  poor with patterns in its output
            let si, r1, r2, rx, rx2;
            const p1 = 3251, p2 = 5261;

			si = (inx + mixID) % listSize;       // allow an over zealous inx
			r1 = mixID % listSize;
			r2 = Math.floor(mixID / listSize);
			rx = Math.floor(mixID / listSize) % listSize + 1;
			rx2 = Math.floor(mixID / listSize / listSize) % listSize + 1;

			// three spin-mix, 2 conditional; and an XOR ops
            if (si < rx) si = ((rx - si - 1) * p2 + r1) % rx;       // mix random half one way
            si = (si * p1 + r2) % listSize;  						// std mod spin-mix:
            if (si < rx2) si = ((rx2 - si - 1) * p1 + r2) % rx2;    // mix another ~half
            si = ((si ^ rx) < listSize) ? si ^ rx : si;

            return (si);  // return 'Shuffled' index
        }


		function faux_PRIG(inx, mixID, listSize) {	// -------  many stats look good, but algo fails PRIG requirements
            let si, r1, r2;
            const p1 = 3251, p2 = 5261;
			si = (inx + mixID) % listSize;
			r1 = mixID % p1 + 1;
			r2 = mixID % p2 + 1;

			if (1) {  // faux_PRIG/bad_Algo
				// three interesting equally interesting variations
				si = ( ( ((Math.floor(si * p2 / 5) % listSize + 1)) * ((si * p1) % listSize + 1) + r1) ^ r2 ) % listSize;   // orig. faux algo
				//si = ((((Math.floor(si * p2 / 5) % listSize + 1)) * ((si * p1) % listSize + 1)) ^ r2 + r1) % listSize;      // makes good graphs but stuck chi=258
				//si = ((((Math.floor(si * p2 / 5) % listSize + 1)) * (((si + (r2 ^ r1)) * p1) % listSize + 1))) % listSize;  // more? faux than 1st two

			} else {   // Alternative, whos raw values form a pyramid distribution Histogram & very interesting plots
				si = Math.floor((getRandomInt(listSize) + getRandomInt(listSize)) / 2);
			}
            return (si);  // return 'Shuffled' index
        }


		function test_Shuffle(inx, mixID, listSize) {
			// TBD testing / DEBUGing ...

			//return MillerShuffleAlgo_d(inx, mixID, listSize);
            //return MillerShuffle_lite(inx, mixID, listSize);
			//return MillerShuffle_xlite(inx, mixID, listSize);
		}


		// ----------------------------  Randomness Statistics Calculations (to fill statistics table)...
		//===========================================================================================

		function calculateStats(array) {  // Calculate Random Statistic Stats for a given array and current data aspect settings
            let size = array.length;
            let range = 256;
            if (algoOpt == "opt7") size = size / 2;   // patch for Dbl Deck Dealing
            if (size < range) range = size;

            let v = [size];		// the shuffle data single value stats are based on
            let x, y = [size];   // data pair used by stats requiring two points, like Pi calc
			histoCnts = new Array(range).fill(0); // used by Histogram generation function

			for (let i = 0; i < size; i++) {
				// set values used in stat calcs based on desired data aspect being characterized
				x = array[i];
				if (dvData) {  // delta v
					//let x2 = array[(i + 1) % range];
					let x2 = (i > 0) ? array[i - 1] : array[size - 1];  // this appears more reflective
					let dv = x - x2;
					if (dv < 0) dv += range;  // rap around difference of (0-255)
					v[i] = dv;  // v[] is for single value calculation
					y[i] = dv;  // y[] is for x,y[] coordinance (to calc pi)
					histoCnts[dv]++;
				} else if (viData) { // delta i
					let di = (i%range) - x;
					if (di < 0) di += range;  // rap around difference of (0-255)
					v[i] = di;
					y[i] = i;
					histoCnts[di]++;
				} else { // our normal processing of the data set
					v[i] = x;
					y[i] = array[(i + 1) % range];
					if (rawX) histoCnts[x]++;
					else histoCnts[(x ^ y[i]) % range]++;  // default for PRIG random representation for the value combination of v0 & v1
				}
			}

            // ---------- Mean calculation
            let sum = 0;
            for (let i = 0; i < size; i++) { sum += v[i]; }
            let mean = sum / size;

            let sumSquares = 0;
            for (let i = 0; i < size; i++) { sumSquares += Math.pow(v[i] - mean, 2); }
            let stdDev = Math.sqrt(sumSquares / size);

            // ---------- Chi-Squared test, now supports multiple data views
            const values = [];
            for (let i = 0; i < size; i++) {
				let x = v[i];
				if (!(dvData || viData)) {	// ------ special Chi2 handling suitable for Shuffled Values vs "random" ones
					// for Chi2 "Shuffles" can't use just: array[i] as there is always equal count (1) of every value ...
					// therefore using adjacent values XORed, as this proves to gives excellent comparable Chi2 results
					x = (array[i] ^ array[(i + 1) % range]) % range;  // 'range' need be 2**n for this to be truly fully valid
					//x = (array[i] + array[(i + 1) % range]) % range; // this "+" combination makes every algo look good
					//x = array[i] ^ (i % range);  // surprisingly, not as representative
                    if (algo == 1 && algoOpt == "opt1") x = array[i];  //  normalize for identity set 
				}
                values.push(x);
            }

			valCounts = new Array(range).fill(0);  // count the frequencies of the values
            for (const val of values) {
                valCounts[val]++;
            }
            let expectedValFrequency = values.length / range; // Expected frequency (usually =1 as gen'd size values over size range)
            let ChiSquared = 0;
            for (let i = 0; i < range; i++) {
                ChiSquared += Math.pow((valCounts[i] - expectedValFrequency), 2) / expectedValFrequency;
             }

            var rvSum = 0;
            var cnt = 0;
            // ---------- Relative Displacement aka: Vector average magnitude (from before shuffling to after)
            for (let i = 0; i < range; i++) {	// only traverse the first data set of items
                for (let j = 0; j < range; j++) {
                    var dist = (array[j] - array[i]);
                    if (dist > 0 && dist < (5)) {  // check just the ones that were close, some algo do poorly with them
                        var newDist = (j - i);
                        var rVec = newDist - dist;
                        if (rVec < 0) rVec += range;
                        rvSum += rVec;
                        cnt++;
                    }
                }
            }
            let relVecMag = rvSum / cnt;  // overall average SB ~= the mean

			// ---------- The "Up/Down Rule" (1.5 Rule) lengths of runs of increasing or decreasing values will average 1.5
			let d_cnt = d_sum = dsumCnt = 0;
			let dir = false;
			for (let i = 0; i < size; i++) {
				d_cnt++;   // direction cnt, # of consecutive increased or decreased values
				x = v[i];
				let x1 = v[(i + 1) % size];
				if ((x > x1) != dir) {
					dir = (x > x1);
					d_sum += d_cnt;
					dsumCnt++;
					d_cnt = 0;
				}
			}
			let calcUpDn = (d_sum / dsumCnt);  // avg consecutive Up / Down cnt
			let udError = 100 * (calcUpDn - 1.50) / 1.50;

            // ---------- Pi calculation based on points which fall in a circle
            const r_sqrd = (range - 1) * (range - 1);
            let incircle = 0;
            var montepi;
            for (let i = 0; i < size; i++) {
				x = array[i];
                montepi = (x * x) + (y[i] * y[i]);
                if (montepi < r_sqrd) incircle++;
            }
            let calcPi = (4.0 * incircle / size);
            //let piError = 100 * Math.abs(calcPi - 3.14159) / 3.14159; // calculate % err
            let piError = 100 * (calcPi - 3.14159) / 3.14159;

			let avgError;  // scaled back the 'UpDown rule's effect due to its natural greater reactiveness
			if (udError < 1000) avgError = (2 * Math.abs(piError) + Math.abs(udError)) / 4;  // calc an Avg. Error (udError is expected to be 2x as big, so results is 1x)
			else avgError = Math.abs(piError);  // to handle identity outlier

            // limit the number of reported decimal places, saving the wide spread use of .toFixed()
				mean = Math.floor(100 * mean) / 100;
			//deltaMean = Math.floor(100 * deltaMean) / 100;
			deltaMean = 0; // no longer used from here
			relVecMag = Math.floor(100 * relVecMag) / 100;
			stdDev = Math.floor(100 * stdDev) / 100;
			ChiSquared = Math.floor(100 * ChiSquared) / 100;
			piError = Math.floor(100 * piError) / 100;
			avgError = Math.floor(100 * avgError) / 100;
			return { ChiSquared, relVecMag, mean, deltaMean, stdDev, piError, avgError };
        }



		function calculateExpectedStats(size) {
            const expectedMean = ((size - 1) / 2);
			const expectedDeltaMean = expectedMean;
			const expectedRelVecMag = expectedMean;
			let expectedStdDev = Math.sqrt((size * size - 1) / 12); // Expected std dev of deltas
            expectedStdDev = (Math.floor(100 * expectedStdDev) / 100);
			const expectedChiSquared = "255"; // size - 1; // Expected Chi-squared (degrees of freedom)
			const expectedPiError = "0.0";
			const expectedAvgError = "0.0";
			return { ChiSquared: expectedChiSquared, relVecMag: expectedRelVecMag, mean: expectedMean, deltaMean: expectedDeltaMean, stdDev: expectedStdDev, piError: expectedPiError, avgError: expectedAvgError };
		}

        // Generate a single unsigned 32-bit random number
        function getUint32Random() {
            return Math.floor(Math.random() * 4294967295);
        }

		// --------------------------------------------------
		function updateStats(algo) {  // used for interval updating of the stats for the current Algo
			const range = 256;
			const sets = 40;	// note: this affects the overall magnitude of the Histogram feature
			const size = sets * range; // for a total data sets of items ranging 0-255 (for total items to be generated)
			let updatedStats = new Object();
			let summedStats = new Array(6 + 1).fill(0);
			let datasetArray = [];

			let dsArrays = [];
			for (let s = 1; s <= sets; s++) { // gether enough data for decent statistical analysis
				updnum++;
				datasetArray = [];
				shuffleID = getUint32Random(); // randomly set the shuffleID for each shuffled set
				if (randID) shuffleID = randID + s;  // overRide for testing
				if (algo == 1) datasetArray.push(...identity(range));
				else if (algo == 2) datasetArray.push(...humanShuffle(range));
				else if (algo == 3) datasetArray.push(...fisherYatesShuffle(range));
				else if (algo == 4) datasetArray.push(...MSA_PRIG_Array(range));
				else if (algo == 5) datasetArray.push(...randomScaled(range));
				dsArrays.push(...datasetArray);

				updatedStats = calculateStats(datasetArray);
				// note stats from 20x shuffles averaged is more telling than stats taken from a dataset 20x in size
				summedStats[1] += updatedStats.ChiSquared;
				summedStats[2] += updatedStats.relVecMag;
				summedStats[3] += updatedStats.mean;
				summedStats[4] += updatedStats.stdDev;
				summedStats[5] += Math.abs(updatedStats.piError);
				summedStats[6] += Math.abs(updatedStats.avgError);

				if (algoOpt != "opt5") dump = false;
			}

			rows[algo - 1].cells[1].textContent = (summedStats[1] / sets).toFixed(0);
			rows[algo - 1].cells[2].textContent = (summedStats[2] / sets).toFixed(2);
			rows[algo - 1].cells[3].textContent = (summedStats[3] / sets).toFixed(2);
			rows[algo - 1].cells[4].textContent = (summedStats[4] / sets).toFixed(2);
			rows[algo - 1].cells[5].textContent = (summedStats[6] / sets).toFixed(2);  // use Avg % Error, instead of just Pi err
			//rows[algo - 1].cells[5].textContent = (summedStats[5] / sets).toFixed(2) + " " + (summedStats[6] / sets).toFixed(2);

			if (iStack && Hist) {
				updatedStats = calculateStats(dsArrays); // prepare data of the multi array dataset for the histogram
				displayHistogram();
			}
		}

		function displayHistogram() {	// overlay Histogram to bottom of the snowy view port
            let h;
			let range = 256;

            for (let i = 0; i < range; i++) {
                // -------------------------------- Redraw Item count Stack bar chart
				if ((lastStack.length > 0)) {
					h = lastStack[i] + 8;
                    ctx.fillStyle = bGnd; // '#124';  // '#124'; // first reset it
                    //ctx.fillStyle = `rgba(17, 34, 68, 1.0)`;
					ctx.fillRect(i * 2, 514 - 2 * h, 4, 2 * h); // extra erase patch
                }
				h = histoCnts[i];
                if (h != 0) {
                    if (i & 1) ctx.fillStyle = `rgba(255, 255, 0, 0.9)`;  // stagger the coloring
                    else ctx.fillStyle = `rgba(255, 180, 0, 1)`;
                    ctx.fillRect(i * 2, 514 - 2 * h, 2, 2 * h);
                }
            }
			lastStack = histoCnts;
		}


		// ----------------------------  Temporal Randomness Statistics Calculations ...
		// -----------------------------------------------------------------------------
		// --- Configuration ---
		const NUM_TRIALS = 100;  // Outer loop count
		const SEQ_LENGTH = 256;  // Inner loop count (numbers in each sequence)
		const NUM_RANGE = 256;   // The range of numbers, 0-255

		// ----------------------- support a variable algo based shuffle
		let items = 256;
		let theMix = [items];
		// used be the Unique_Temporal_Stats()
		function algoShuffle(inx, mixID, nItems) {  // provides shuffle results for the current "algo"
			// these globals need to get reinitialize each time balls are "reracked"
			inx = inx % nItems;
			if (randID) mixID = randID;  // overRide for testing
			shuffleID = mixID; // set the globally used by some algo
			if (inx == 0) { // init theMix[] if needed
				// setup needed array 'theMix[]' for Fisher-Yates algo (& Humans) as it must shuffle items all together at once.
				// Miller Shuffle Algos will simply pick from the remaining items as needed. As for random() it picks items out of the air.
				if (algo == 1) theMix = identity(nItems);
				if (algo == 2) theMix = humanShuffle(nItems);
				else if (algo == 3) theMix = fisherYatesShuffle(nItems);
			}

			let shuffledIndex;
			if (algo == 1) shuffledIndex = theMix[inx];				// for Identity just return the indexing 'selectNum'
			else if (algo == 2) shuffledIndex = theMix[inx];
			else if (algo == 3) shuffledIndex = theMix[inx];
			else if (algo == 4) shuffledIndex = MSA_PRIG(inx, mixID, nItems);  // gets next shuffled index item
			else if (algo == 5) shuffledIndex = Math.floor(Math.random() * nItems);  // gets random value from within the range
			return shuffledIndex;
		}

		function total_variation_distance(p, q, exp, n) {
			// exp is expected average count, n is array element cnt
			// a "normalized" TVD is returned
			let pv, qv, tvd = 0.0;
			//printf("exp, p[]/q[]   %d %d  %d\n", exp, p[0], q[0]);
			for (let i = 0; i < n; i++) {
				// Normalize to get the probability distributions
				pv = p[i] / exp / n / 2;
				qv = q[i] / exp / n / 2;
				//printf("p/q   %f  %f\n", pv, qv);
				//tvd += fabs(pv - qv);
				if (pv > qv) tvd += (pv - qv);
				else tvd += (qv - pv);
			}
			return tvd * (exp / n) / 2.0;
		}


        // -----------------  Calculate Temporal Randomness statistics and for Uniqueness Generation
		//document.getElementById('run-test-btn').addEventListener('click', () => {
		function Unique_Temporal_Stats() {
			// --- Variables for storing aggregate statistics across all trials ---
			let totalRuns = 0;
			let totalAutocorrelation = 0;
			let randTot = 0;

			let output = "Temporal Randomness  &  Uniqueness Generation statistics...\n";

			// --- Run the full analysis multiple times ---
			for (let trial = 0; trial < NUM_TRIALS; trial++) {
				let sequence = [];
				let sum = 0;
				let lastx = 0;
				var value;

				//randID = 31416 + trial + 1; // use overRide for repeatability Testing (also =ing .c results)
				let mixID = Math.floor(Math.random() * 4294000000);
				if (randID) mixID = randID;  // overRide for testing
				shuffleID = mixID; // set this globally, as may be used
				// --- Inner Loop: Generate one full sequence of numbers ---
				for (let i = 0; i < SEQ_LENGTH; i++) {
					// To see how the tests fail, comment the first line and uncomment the second.
					let x = algoShuffle(i, mixID, SEQ_LENGTH);
					let dv=0;

                    // -------- support different data prospective
					if (dvData) {  // delta v
                        if (i>0) dv = x - lastx;
                        if (dv < 0) dv += range;  // rap around difference of (0-255)
						value = dv;
                        lastx = x;
                    } else if (viData) { // delta i
                        let di = i - x;
                        if (di < 0) di += range;  // rap around difference of (0-255)
                        value = di;
                    } else { // our normal processing of the data set
                        value = x;
					}
					// --------

					sequence.push(value);
					sum += value;
				}
				//randID = 0; // clear this override
				randTot += shuffleID;

				// ------------ Runs Test (Wald-Wolfowitz)
				// A "run" is a series of consecutive points all above or all below the median.
				const median = (NUM_RANGE - 1) / 2.0;
				let currentRuns = 1;
				let lastStateIsAbove = sequence[0] > median;

				for (let i = 1; i < SEQ_LENGTH; i++) {
					const currentStateIsAbove = sequence[i] > median;
					// If the state changes (above <-> below), it's a new run.
					if (currentStateIsAbove !== lastStateIsAbove) {
						currentRuns++;
					}
					lastStateIsAbove = currentStateIsAbove;
				}
				totalRuns += currentRuns;

				// ------------- Autocorrelation (lag: 1-5)
				// Checks if a number is correlated with the number that came at a point before it.
				const mean = sum / SEQ_LENGTH;
				let numerator = 0.0;   // Sum of (x_i - mean) * (x_{i-lag} - mean)
				let denominator = 0.0; // Sum of (x_i - mean)^2

				let lag = trial % 5 + 1;  // use lag of 1-5, to be more general, 4 is important for most card games
				for (let i = 0; i < SEQ_LENGTH; i++) {
					denominator += (sequence[i] - mean) ** 2;
					if (i > (lag - 1)) {
						numerator += (sequence[i] - mean) * (sequence[i - lag] - mean);
					}
				}
				numerator += (lag / 2); // fine detail adjmt
				if (denominator !== 0) totalAutocorrelation += Math.abs(numerator / denominator);  // with abs the stat is more useful
			}
			//output += "randTot: " + randTot + "\n";

			// --- Final Statistics Calculation and Output ---
			const avgRuns = totalRuns / NUM_TRIALS;
			const avgAutocorrelation = totalAutocorrelation / NUM_TRIALS;

			// For a random sequence, the expected number of runs is E = (2*n1*n2)/(n1+n2) + 1
			const expectedRuns = (2.0 * (SEQ_LENGTH / 2.0) * (SEQ_LENGTH / 2.0)) / SEQ_LENGTH + 1.0;


			output += `  Time based...    avg Observed Runs(129): ${avgRuns.toFixed(2)}`;
			//output += `   Expected Runs for Random Data: ${expectedRuns.toFixed(2)}\n`;
			output += `   avg Lag Coefficient(<): ${avgAutocorrelation.toFixed(4)}\n`;
			//output += "   Ideal Value for Random Data: 0.0\n";

            //---------- now lets test for Uniqueness Generation capabilites -----------
			// (aka Flush Distro) check the distribution of suits for 5 card hands dealt
			// possible 5 card suit hands 4^5 = 1024
			// sort of a hybrid of a combination and ordered permutation

			const posi = 1024;  // 4*4*4*4*4
			let combo = new Array(1025); // accumulates results of suit combo-permutation of hands dealt
			// hand of 5 cards each 1of4 suits = 4*4*4*4*4 = 1024 possibilities
			let suitP;
			let ci; // card index dealt
			let dSize = 52;
			let exp = 100; // set to expect 100 cnt in each case
			let hands = posi * exp;
			let d, h; //deck, hand cnt

			let maxCnt = 0;
			let cnt = 0;
			let i, s;

			randTot = 0;
			for (i = 0; i < 1024; i++) combo[i] = 0;

			for (d = 1; d <= hands / 10; d++) {  // we get 10 hands 0f 5 out of 52 cards
				let mixID = Math.floor(Math.random() * 4294000000);
				//mixID = 31416 + d; // for repeatability testing
				shuffleID = mixID; // set this globally, as may be used

				suitP = 0;
				randTot += shuffleID;
				for (let i = 0; i < dSize; i++) {
					ci = algoShuffle(i, mixID, dSize);

					// -------- support different data prospective
					let dv = 0;
					let range = dSize;
					x = ci;
                    if (dvData) {  // delta v
                        if (i > 0) dv = x - lastx;
                        if (dv < 0) dv += range;  // rap around difference of (0-255)
                        ci = dv;
                        lastx = x;
                    } else if (viData) { // delta i
                        let di = i - x;
                        if (di < 0) di += range;
                        ci = di;
                    } // else { // our normal processing of the data set
					//--------

					suitP = 4 * suitP + Math.floor(ci / 13); // * up & + in to build a # representing the 5 digits (of 0-4)
					if (i % 5 == 4) {	// from each shuffled deck deal out 10 hands of 5
						cnt++;
						combo[suitP]++;
						suitP = 0;
					}
				}
			}

			output += "  Combo/Permu Gen:  ";
			//output += "randTot: " + randTot + "\n";

			let devi = 0;
			for (let s = 0; s < 1024; s++) {
				//if (verbo) printf("  %d", combo[s]);
				devi += Math.abs(combo[s] - exp);  // 100 is the expected val
			}

			output += ` avg. Deviation(<):  ${(100 * devi / (1024) / exp).toFixed(2)}% `;
			let tvd = total_variation_distance(combo, combo.slice(512), exp, posi / 2);
			output += "  Total Variation Distance(<<):  " + tvd.toFixed(4) + "\n";

			// Display results
			document.getElementById('results-output').textContent = output;
			document.getElementById('results-container').classList.remove('hidden');

		}//);


        /***
		//----------------------------------------------------------------------------
		//  show MSA algo chksums
		let randCut = 314159;
		var ss = "<br/>Chksums and validity testing with Aug 2025 update version: <br/>";
		document.getElementById('chksumArea').innerHTML += ss;
		ss = "";
		randCut = 314159;
		//let chks = algoChkSum(4, randCut); ss = ss + " &nbsp; &nbsp; ChkSum &nbsp; &nbsp;MSA_d: " + chks;
        let chks = algoChkSum(5, randCut);   ss = ss + " &nbsp; &nbsp; ChkSum &nbsp; &nbsp;MSA_e: &nbsp;" + chks;
		chks = algoChkSum(6, randCut); ss = ss + "&nbsp; MS_lite: &nbsp;" + chks;
        ss = ss + "<br/>\n &nbsp; &nbsp; Expect: &nbsp; &nbsp; MSA_e= 5980121 &nbsp;MS_lite= 6115927 \n<br/>"; // 2025 ver values
		ss = ss + "<small>";

		randCut = 0xFFFFFFFF;  // this catches all known and imagined edge cases
		//ss = ss + " &nbsp; &nbsp; &nbsp; 0FFFFFFFF: &nbsp;MSA_d: " + algoChkSum(4, randCut);
        ss = ss + " &nbsp; &nbsp; &nbsp; 0FFFFFFFF: &nbsp;MSA_e: &nbsp;" + algoChkSum(5, randCut);
        ss = ss + " &nbsp;MS_lite: &nbsp;" + algoChkSum(6, randCut);
		//ss+="<br/>\n";
        ss += "<br/>\n &nbsp; &nbsp; &nbsp; &nbsp; expect: &nbsp; &nbsp; &nbsp; &nbsp; MSA_e= 6454819 &nbsp;MS_lite= 6268132 ";
		document.getElementById('chksumArea').innerHTML += ss + "</small><br/>\n";
		randCut = 0;  // disable shuffleID override
		//----------------------------------------------------------------------------
		/***/


		//======================================= Produce Snow Flurry based on selected Algorithm
		//=======================================================================================
		const speedSlider = document.getElementById('speedSlider');
		const numItems = 256;
		let maxdSize = 4;
		let dotData = {};
		let cntData = {};
		let pixel;
		let flurryArray = [];
		let currentX = 0;
		let currentY = 0;
		//		let ptCnt = 0; // running count of point generation
		//		let flurryID = 314159;

		let maxdc = 0;
		let limitCnt = 0;
		let newDots = true;

		for (i = 0; i < numItems; i++) cntData[i] = bGnd;

		function getRandomInt(limit) {
			return Math.floor(Math.random() * limit);
		}

		// To form a Snow Flurry, we want to continuously generate points (Snow Flakes) to plot on the Fly.
		// MSA does that naturally,  as does random().
		// Fisher-Yates, as well as Human shuffles, requires a group (array) of items, like a desk of cards to manipulate.
		function next_SnowFlake() {
			let item;
			inx = ptCnt % numItems
			if (inx == 0) {
				//flurryID++;   // this does not work well with 'test Shuffle' plot of occurrences
                flurryID = getUint32Random();
				if (algo == 2) flurryArray = humanShuffle(numItems);
				if (algo == 3) flurryArray = fisherYatesShuffle(numItems);
			}

			ShuffleID = flurryID;  // used by some algos
			if (algo == 1) {
                if (algoOpt == "opt7") item = DDeck_Shuffle(ptCnt, numItems);
                else if (algoOpt == "opt8") item = weak_PRIG(ptCnt, flurryID, numItems);
                else if (algoOpt == "opt9") item = poor_PRIG(ptCnt, flurryID, numItems);
                else if (algoOpt == "opt10") item = faux_PRIG(ptCnt, flurryID, numItems);
                else if (algoOpt == "opt11") item = test_Shuffle(ptCnt, flurryID, numItems);
				else item = inx;				// for Identity just return index (0 - numItems-1)
			}
			else if (algo == 2) item = flurryArray[inx];
			else if (algo == 3) item = flurryArray[inx];
			else if (algo == 4) item = MSA_PRIG(ptCnt, flurryID, numItems);
			else if (algo == 5) item = getRandomInt(numItems);  // simply another random value from within the range
			return item;
		}

		function drawDot(x, y, brightness, size) {
			if (size > maxdSize) size = maxdSize;
			ctx.fillStyle = bGnd; // first reset its back gnd
			ctx.fillRect(x * 2, y * 2, maxdSize, maxdSize);
			ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
			ctx.fillRect(x * 2, y * 2, size, size);
		}

		// ---------------------------------------------------
		function update() {  // draw next snow flake (aka dot) & update while aging prior flakes
			const prevX = currentX;
			if (scatterPlot) {
				OPlot_update();		// do an aggregating plot
                OPlot_update();
                OPlot_update();		// at quadruple max speed
                return OPlot_update();
			}

			if (!isPaused) {
                maxdSize = 4;
				currentX = next_SnowFlake();
				if (document.getElementById('dvData').checked)  // go by what page says
					currentY = (currentX > prevX) ? currentX - prevX : 256 + currentX - prevX; // use X,deltaV
				else {
					if (viData) {
						let di = (ptCnt % numItems) - currentX;
						if (di < 0) di += numItems;  // rap around difference of (0-255)
						currentX = di;
						currentY = ptCnt % numItems;  // revealing/informative & rains down the screen 'snowing' // use X,i
					}
					else currentY = prevX;  // default: use consecutive X values, for good randomness representation
				}
				ptCnt++;

				// Clear the previous dot
				if (dotData[currentX]?.lastY !== undefined) {
					ctx.fillStyle = bGnd; //'#124';  // bGnd; // Background color
					ctx.fillRect(currentX * 2, dotData[currentX].lastY * 2, 4, 4);
				}

				// Update dotData
				dotData[currentX] = {
					lastX: currentX,
					counter: 0,
					lastY: currentY
				};

				// Draw the new dot
				drawDot(currentX, currentY, 1, 4);

				// Update existing dots
				if (document.getElementById('aging').checked) {
					const dotKeys = Object.keys(dotData); // Get the keys *once*
					for (const x of dotKeys) {        // Iterate over the COPY
						dotData[x].counter++;
						const { counter, lastY } = dotData[x];
						var brightness = Math.max(0, 1 - (counter / 320));
						const size = Math.floor(0 + brightness * 5);
						if (size == 1) { brightness = 2 * brightness; }

						drawDot(x, lastY, brightness, size);
					}
				}
			}
		}


		// added colored coded frequency of dot (x,y) Occurrence Plotting
		// ----------------------------------------------------------------------
        function OPlot_update() {  
			const prevX = currentX;
			if (!isPaused) {
				currentX = next_SnowFlake();
				if (document.getElementById('dvData').checked)  // go by what page says
					currentY = (currentX > prevX) ? currentX - prevX : 256 + currentX - prevX; // use X,deltaV
				else {
					//if (viData) currentY = ptCnt % numItems;  // revealing/informative & rains down the screen 'snowing' // use X,i
					if (viData) {
						let di = (ptCnt % numItems) - currentX;
						if (di < 0) di += numItems;  // rap around difference of (0-255)
						currentX = di;
						currentY = ptCnt % numItems;  // revealing/informative & rains down the screen 'snowing' // use dI,i
					}
					else currentY = prevX;  // default: use consecutive X values, for good randomness representation
				}

                ptCnt++;
				// track the wide spread occurances
				let n = ++pts[currentX][currentY];
				if (n == 1) {
					++newPts;	// note there are 256 (v0,v1) pts out of 65535 that PRIGs won't hit
                    if (newPts == 32767) console.log("At " + ptCnt + "  1/2 the possible grid points have been generated.\n");
                    if (newPts == 58981) console.log("At " + ptCnt + "  90% of possible grid points have been generated.\n");
                    if (newPts == 64880) console.log("At " + ptCnt + "  99% of possible grid points have been generated.\n");
                    if (newPts == 32767) diagLog.innerText += "\nAt " + ptCnt + "  1/2 the possible grid points have been generated.\n";
                    if (newPts == 58981) diagLog.innerText += "At " + ptCnt + "  90% of possible grid points have been generated.\n";
                    if (newPts == 64880) diagLog.innerText += "At " + ptCnt + "  99% of possible grid points have been generated.\n";
				}
				if (n < 26) {
					--nCnt[n - 1];  // remove cnt from previous tally
					++nCnt[n];
				}

				maxdSize = 2;
				let matured = false;

				// Redraw the previous dot at this locale with color representing its # of occurances
				let fastBW = false; // if set true you get Blk&Wht plot but very quickly
                if (dotData[currentX]?.lastY !== undefined && !fastBW) {
					let r = 0;
					let g = 0;
					let b = dotData[currentX].dColor;
					if (b == 255) matured = true;

					if (b < 128) { g = b; } // at low levels make it b-g gray
					else {
						g = 50;
						r = 16 + (b - 128) / 2;
					}
					if (b > 248) r += (b - 248) * 23;
					if (b == 255) r = 255;

					if (currentX == 4 && dotData[currentX].lastY == 3) console.log("b=", b, "  r=", r, "  g=", g)
					if (b > 255) b = 255;
					a = 1;
					ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
					ctx.fillRect(2 * currentX, 2 * dotData[currentX].lastY, maxdSize, maxdSize);
				}

				let pixel = ctx.getImageData(currentX * 2, currentY * 2, 1, 1).data; // save pixel info
				let dColor = pixel[2];
				if (dColor != 255) {
					//if (dColor >= 248) dColor += 1;
                    //else if (dColor > 128) dColor += 8;   // slow developing
					//else dColor += 32;

					// this set (of dColor stepping) for faster developing color depth, STD
					if (dColor >= 248) dColor += 1;
					else if (dColor > 200) dColor += 16;
					else if (dColor > 96) dColor += 24;
					else dColor += 32; // make it progress faster 

                    // for use with poor PRIG to get better fan out of colors (High Contrast)
                    //if (dColor >= 248) dColor += 1;
                    //else if (dColor > 200) dColor += 8;
                    //else if (dColor > 96) dColor += 16;
                    //else dColor += 16; // make it progress progress slower than with  32;

				}

				//if (dColor > maxdc) {
				//	console.log("ptCnt: ", ptCnt, "max dColor:", dColor); maxdc = dColor;
				//}
				if ((ptCnt % 25000 == 0)) console.log("ptCnt: ", ptCnt, "   limitCnt:", limitCnt);

				if (dColor >= numItems && dColor == 256) {   // spc chk ==256 to be sure it is the first time > numItems
					limitCnt++;
					//console.log("ptCnt: ", ptCnt, "   limitCnt:", limitCnt);
				}
				if (ptCnt > 99000) newDots = false;

				// !!! Stop after time plot well filled up.  (only done with dev tools open)
				if (ptCnt == 100000) {	// Execution will pause here, with 'best' distro representation image
					console.log("point count occurrences out of 100K: \n" + nCnt);  // logs the array values
                    let pp = (100 * newPts / 65536).toFixed(1);
                    console.log("% of possible points generated " + pp + " after 100K\n");
					diagLog.innerText += "% of grid points that got generated: " + pp + " after 100K\n";
					debugger;
                    document.getElementById('notice').innerHTML = "Plot will continue to slowly evolve."
				}
				if (ptCnt == 250000) {
					console.log("point count occurrences out of 250K: \n" + nCnt);
                    let pp = (100 * newPts / 65536).toFixed(1);
					console.log("% of possible points generated " + pp + " after 100K\n");
                    diagLog.innerText += "% of grid points that got generated: " + pp + " after 250K\n";
					debugger;
				}

                if (dColor >= 256) dColor = 249;
				//if (dColor > 256) dColor = 255;  // dbl chk
				if (dColor > maxdc) {
					console.log("ptCnt: ", ptCnt, "max dColor:", dColor); maxdc = dColor;
				}

				// Update dotData
				dotData[currentX] = {
					lastX: currentX,
					age: 0,
					dColor: dColor,
					lastY: currentY
				};

				// Draw the new dot
                if (newDots && limitCnt != 1 && !matured)  // don't do if we might do an image capture
					drawDot(currentX, currentY, 0.5, 4);

			}
		}

		// called by radio button event, when changing algo
		function clearCanvas() {
			dotData = {}; // clear out the old points
			ptCnt = 0;
			currentX = 0;
			maxdc = 0;
			limitCnt = 0;
			newDots = true;
			newPts = 0;
			for (let x = 0; x< 256; x++) {
				for (let y = 0; y< 256; y++) pts[x][y] = 0;
			}
			for (let n = 0; n <= 25; n++) nCnt[n]=0;

			clearInterval(intervalId); // Stop the update interval
			ctx.fillStyle = bGnd;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			// Restart the interval immediately after clearing
			intervalId = setInterval(update, 10000 / (speed * speed));
		}

		speedSlider.addEventListener('input', () => {
			clearInterval(intervalId);
			speed = speedSlider.value;  // value range 2-72  for ~2.5sec to 2 millisecs/update (Chrome goes faster than FireFox)
			intervalId = setInterval(update, 10000 / (speed * speed));
			//document.getElementById('diagArea').innerHTML += "Intrvl=" + 10000 / (speed*speed)  + "<br/>";
			//console.log("speed=", speed)
		});

		// Clear and set background color initially
		ctx.fillStyle = bGnd;
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// start up the Snow Flurry display
		let speed = speedSlider.value;
		let oldSpeed = speed;
		let intervalId = setInterval(update, 10000 / (speed * speed));


		//============================================  Pool Ball PRIG selection (LOTO) animation
		//=======================================================================================
		// Loto: Pulls out one of the available items at a time. (done here until all have been selected)

		const firstLine = document.getElementById('firstLine');
		const secondLine = document.getElementById('secondLine');
		const ballContainer = document.getElementById('ballContainer');
		const numBalls = 15;
		const ballImages = [];
		const bWidth = 50;

		for (let i = 0; i <= numBalls; i++) {
			ballImages.push(`images/ball${i}.png`);
		}

		let balls = [];
		let ballsOnSecondLine = [];
		let nextSecondLineX = 0;
		let lotoMix = [numBalls];
		let lotoID;
		let selectNum = 0;
		let init = 0;
		let remaining;
		let stats = [];

		function createBalls() {
			// these globals need to get reinitialize each time balls are "reracked"
			balls = [];
			ballsOnSecondLine = [];
			firstLine.innerHTML = '';
			secondLine.innerHTML = '';
			nextSecondLineX = 0;
			init = 0;
			selectNum = 0;
			remaining = 15;
			lotoID = Math.floor(Math.random() * 1000000);  // Identifies the Shuffle  (with 0-999999 random instances)
			if (randID) lotoID = randID;  // overRide for testing
			shuffleID = lotoID;  // dbl-Deck uses this

			// setup needed array 'lotoMix[]' for Fisher-Yates algo (& Humans) as it must shuffle items all together at once.
			// Miller Shuffle Algos will simply pick from the remaining items as needed. As for random() it picks items out of the air.
			if (algo == 1) lotoMix = identity(numBalls);
			else if (algo == 2) lotoMix = humanShuffle(numBalls);
			else if (algo == 3) lotoMix = fisherYatesShuffle(numBalls);
			else if (algo == 4) lotoMix = MSA_PRIG_Array(numBalls);
			else if (algo == 5) lotoMix = randomScaled(numBalls);

			for (let i = 1; i <= numBalls; i++) {
				const ball = document.createElement('div');
				ball.classList.add('ball');
				ball.style.backgroundImage = `url(${ballImages[i]})`;
				ball.dataset.id = i;
				ball.startX = (i - 1) * bWidth;
				ball.style.left = `${ball.startX}px`;
				firstLine.appendChild(ball);
				balls.push(ball);
			}
		}

		function pickRandomBall() {	// pick a 'random' ball from the mix, move it to the end of the selected balls on line 2
			if (!isPaused) {
				if (remaining == 0) {
					remaining--;	 // 1 step pause when finished
					return;
				}
				if (balls.length === 0 || remaining <= 0 || init == 0) {
					createBalls();
					init++;
					return;
				}

				if (selectNum == 1) {
					if (diag) {  // -------- diag/interest
						stats = randCalcRuns(0, 15, 1); // special case, calculates stats for the previous loto balls
						document.getElementById('ballShuffleStats').innerHTML = " Pool Loto 15 item shuffle Stats: &nbsp; " + JSON.stringify(stats);
						stats = randCalcRuns(algo, 15, 100);
						document.getElementById('ballShuffleStats').innerHTML += "<br/> 100x 15 item shuffle Stats: &nbsp;" + JSON.stringify(stats);
                        stats = randCalcRuns(algo, 52, 40);
                        document.getElementById('ballShuffleStats').innerHTML += "<br/> 40x 52 item shuffle Stats: &nbsp; " + JSON.stringify(stats);
						stats = randCalcRuns(algo, 256, 40);
						document.getElementById('ballShuffleStats').innerHTML += "<br/> 40x 256 item shuffle Stats: &nbsp;" + JSON.stringify(stats);
					}
				}

				if (selectNum >= lotoMix.length) {  // handle non-PRIG short selections
					//console.log(" selectNum=", selectNum);
					if (algo == 1) lotoMix.push(...identity(numBalls));  // we have not selected all of the 15, so get another set of selections
					if (algo == 5) lotoMix.push(...randomScaled(numBalls));
				}
				const allBalls = balls.concat(ballsOnSecondLine);
				let shuffledIndex = lotoMix[selectNum];
				selectNum++;

                const selectedBall = allBalls[shuffledIndex % allBalls.length];  // make sure selectedBall is in range
				document.getElementById('selCnt').innerHTML = selectNum;
				document.getElementById('ball').innerHTML = selectedBall.dataset.id;
				const targetY = bWidth;
				let targetX = nextSecondLineX;
				if (selectNum < 25) nextSecondLineX += bWidth;
				else nextSecondLineX += (bWidth / 8);
				if (!scatterPlot) {
					selectedBall.style.transition = 'transform 0.4s ease';
					selectedBall.style.transform = `translate(${targetX - selectedBall.offsetLeft}px, ${targetY - selectedBall.offsetTop}px)`;
				}
				// ------ set the ball relocation in motion
				setTimeout(() => {
					selectedBall.style.transition = 'none';

					if (selectedBall.parentNode === firstLine) {
						firstLine.removeChild(selectedBall);
						remaining--;
					} else if (secondLine.contains(selectedBall)) secondLine.removeChild(selectedBall);

					secondLine.appendChild(selectedBall); // Append to the second line FIRST
					selectedBall.style.left = `${targetX}px`; // Then set the left style
					selectedBall.style.top = `${targetY}px`;
					selectedBall.style.transform = 'none';

					ballsOnSecondLine.push(selectedBall);
					selectedBall.style.transition = 'transform 0.3s ease';
				}, 300);
			}
		}

		// kick off PoolBall LOTO selection
		createBalls();
		const interval0 = setInterval(pickRandomBall, 400);


		//=============================================  Diagnostic & Testing late additions

		// As taking randomness statistics on a single 15 item shuffle appears not very informative,
		// do Random Stat Calc over many shuffle outputs (runs).
		// Set initial 'shuffleID' prior to running as desired.
		function randCalcRuns(algo, setSize, runs) {
			// Calcs the stats on the Whole data set at the end, could have calc'd each shuffle and averaged the sums of the stats.
			// But as with 15 items the stats you get are more stable and better for comparison when computed from a larger dataset.
			const size = setSize;
			let array = [size];
			let sum = 0, deltaSum = 0;
			const maxDelta = size;
			let sumSquares = 0;
			let sumDSquares = 0;
			let rvSum = 0, cnt = 0;
			let plus1 = 0;	// cnts # of consecutive items found ShBe: ~=1 (N*1/N) in a shuffled collection of N items (very telling for human shuffle)
			const r_sqrd = (size - 1) * (size - 1);
			let incircle = 0, montepi;
			const expMean = (setSize - 1) / 2;
			let deltaCounts = new Array(setSize).fill(0); // Count delta frequencies

			let d_cnt = d_sum = dsumCnt = 0;   // for u/d 1.5 calc
			let dir = true;

			for (run = 0; run < runs; run++) {
				if (run > 0) {
					shuffleID = getUint32Random(); // randomly set the shuffleID
				}
				if (randID) shuffleID = randID + run;  // overRide for testing
				if (algo == 0) array = lotoMix; // use the last Loto
				else if (algo == 1) array = identity(setSize);
				else if (algo == 2) array = humanShuffle(setSize);
				else if (algo == 3) array = fisherYatesShuffle(setSize);
				else if (algo == 4) array = MSA_PRIG_Array(setSize);
				else if (algo == 5) array = randomScaled(setSize);

				for (let i = 0; i < size; i++) {  // accumulate a meaningful set of measurements
					sum += array[i];
					sumSquares += Math.pow(array[i] - expMean, 2);
					// ---------- Delta Chi-squared test
					let d = (i > 0) ? (array[i] - array[i - 1]) : (array[0] - array[size - 1]);
					let ddir = d > 0; // for u/d 1.5 calc
					if (d < 0) d += maxDelta;  // rap around difference
					deltaSum += d;
					deltaCounts[d]++;
					// using a pre-known expected Mean as opposed to calculated for the given dataset
					// this causes different results from table based Identity & Human -dv but more useful for us
					sumDSquares += Math.pow(d - expMean, 2);  // used for Std_Dev of delta values
					// ---------- Relative Displacement aka: Vector average magnitude
					for (let j = 0; j < size; j++) {
						var dist = (array[j] - array[i]);
						if (dist > 0 && dist < (5)) {  // check just the ones that were close, some algo do poorly with them
							var newDist = (j - i);
							var rVec = newDist - dist;
							if (rVec < 0) rVec += size;
							rvSum += rVec;
							cnt++;  // tracks the # of sample of Relative Displacement taken
						}
					}
					if (i > 0 && array[i] == (array[i - 1] + 1)) plus1++; // cnt items in consecutive order
					// ---------  Pi calculation
					let x = array[i];
					let y = d;
					montepi = (x * x) + (y * y);
					if (montepi < r_sqrd) incircle++;
					// ---------- The "Up/Down Rule" (1.5 Rule) lengths of runs of increasing or decreasing values will average 1.5
					d_cnt++;   // direction cnt, # of consecutive increased or decreased values
					if (ddir != dir) {
						dir = ddir;
						d_sum += d_cnt;
						dsumCnt++;
						d_cnt = 0;
					}
				}
			}

			// ---------- Calculate the statistics
			let sampleSize = setSize * runs;
			let mean = sum / sampleSize;						// Mean calculation
			let stdDev = Math.sqrt(sumSquares / sampleSize);    // stdDev not informative for permutations (mixing a set of fixed items)
			let stdDvDev = Math.sqrt(sumDSquares / sampleSize);  // use std Deviation of Delta values
			let deltaMean = deltaSum / sampleSize;
			let deltaChiSquared = 0;
			let expected = 1 * runs; // Expected frequency of Deltas, 1 each for that of setSize (*runs)
			for (let i = 0; i < setSize; i++) {
				//deltaChiSquared += Math.pow(deltaCounts[i] - expected, 2) / expected;
				deltaChiSquared += Math.pow((deltaCounts[i] / expected), 2); // !specially normalized for multi runs testing & compare
			}

			plus1 = plus1 / runs;  // sb: ~1 (0.98) / shuffle
			let relVecMag = rvSum / cnt;  // overall average SB ~= the mean
			let calcPi = (4.0 * incircle / sampleSize); // ---------- Pi calculation based on points which fall in a circle
			let piError = 100 * Math.abs(calcPi - 3.14159) / 3.14159; // calculate % err
			let calcUpDn = (d_sum / dsumCnt);  // avg consecutive Up / Down cnt
			let udError = 100 * Math.abs(calcUpDn - 1.50) / 1.50;
			let avgError = (2 * piError + udError) / 4;  // calc an Avg. Error (udError is expected to be 2x as big, so results is 1x scale)

			// limit the number of reported decimal places, so json() is easier to read
			mean = Math.floor(100 * mean) / 100; deltaMean = Math.floor(100 * deltaMean) / 100; relVecMag = Math.floor(100 * relVecMag) / 100;
			stdDvDev = Math.floor(100 * stdDvDev) / 100; deltaChiSquared = Math.floor(100 * deltaChiSquared) / 100; piError = Math.floor(100 * piError) / 100;
			avgError = Math.floor(100 * avgError) / 100;

			return { deltaChiSquared, relVecMag, mean, deltaMean, stdDvDev, avgError, plus1 };  // now using stdDvDev instead of stdDev & avgError instead of piError

		}
	</script>

</body>
</html>
